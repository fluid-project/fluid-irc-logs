b'2015-07-28T17:53:12 <simonjb> and if it has responsiliblity for changes, then it is also a single target of optimization
2015-07-28T17:53:19 <Bosmon> yes
2015-07-28T17:54:08 <Bosmon> For example the "revealTile" code in this example: http://www.sitepoint.com/immutability-javascript/
2015-07-28T17:54:20 <Bosmon> With the ChangeApplier, both requests for mutation have the same form
2015-07-28T18:16:47 * Jess_ joined the channel
2015-07-28T18:25:51 * colinclark joined the channel
2015-07-28T18:31:49 * clown has quit
2015-07-28T18:35:41 * colinclark_ joined the channel
2015-07-28T18:39:21 * colinclark_ is now known as colinclark
2015-07-28T18:40:08 * clown joined the channel
2015-07-28T18:40:11 * clown is now known as clown_mtg
2015-07-28T18:41:17 * kasparnet joined the channel
2015-07-28T19:28:27 * michelled joined the channel
2015-07-28T19:54:14 * kasparnet has quit
2015-07-28T19:58:03 * cindyli has quit
2015-07-28T20:08:24 * the-t-in-rtf has quit
2015-07-28T20:15:29 * cindyli joined the channel
2015-07-28T20:16:57 * clown_mtg has quit
2015-07-28T20:33:11 * clown joined the channel
2015-07-28T20:36:24 * kasparnet joined the channel
2015-07-28T20:56:22 * cindyli has quit
2015-07-28T21:00:17 * clown has quit
2015-07-28T21:07:35 * michelled has quit
2015-07-28T21:11:16 * alanharnum has quit
2015-07-28T21:17:40 * kasparnet has quit
2015-07-28T21:37:24 * simonjb has quit
2015-07-28T21:41:32 * Justin_o has quit
2015-07-28T22:12:08 * colinclark has quit
'

b'2015-07-28T00:41:31 * Justin_o has quit
2015-07-28T06:48:12 * the-t-in-rtf joined the channel
2015-07-28T10:05:15 * the-t-in-rtf has quit
2015-07-28T10:25:01 * the-t-in-rtf joined the channel
2015-07-28T12:05:02 * michelled joined the channel
2015-07-28T12:22:44 * Justin_o joined the channel
2015-07-28T12:46:25 * cindyli joined the channel
2015-07-28T13:00:37 * michelled has quit
2015-07-28T13:00:54 * michelled joined the channel
2015-07-28T13:02:44 * michelled has quit
2015-07-28T13:03:02 * michelled joined the channel
2015-07-28T13:04:52 * michelled has quit
2015-07-28T13:05:10 * michelled joined the channel
2015-07-28T13:07:39 * michelled has quit
2015-07-28T13:07:56 * michelled joined the channel
2015-07-28T13:09:46 * michelled has quit
2015-07-28T13:10:03 * michelled joined the channel
2015-07-28T13:10:46 * alanharnum joined the channel
2015-07-28T13:11:16 * simonjb joined the channel
2015-07-28T13:13:04 * michelled joined the channel
2015-07-28T13:13:35 * colinclark joined the channel
2015-07-28T13:14:35 * anastasiac joined the channel
2015-07-28T13:15:52 * michelled has quit
2015-07-28T13:16:10 * michelled joined the channel
2015-07-28T13:17:59 * michelled has quit
2015-07-28T13:18:17 * michelled joined the channel
2015-07-28T13:20:07 * michelled has quit
2015-07-28T13:20:24 * michelled joined the channel
2015-07-28T13:22:31 * michelled joined the channel
2015-07-28T13:24:21 * michelled has quit
2015-07-28T13:24:38 * michelled joined the channel
2015-07-28T13:26:29 * michelled has quit
2015-07-28T13:26:46 * michelled joined the channel
2015-07-28T13:28:04 * maozillah joined the channel
2015-07-28T14:03:32 * cindyli has quit
2015-07-28T14:20:23 * cindyli joined the channel
2015-07-28T14:33:40 * kasparnet joined the channel
2015-07-28T15:16:42 * kasparnet has quit
2015-07-28T15:22:21 * kasparnet joined the channel
2015-07-28T15:23:57 * kasparnet has quit
2015-07-28T15:24:37 * kasparnet joined the channel
2015-07-28T15:28:53 * kasparnet has quit
2015-07-28T15:43:59 * michelled has quit
2015-07-28T15:45:32 * michelled joined the channel
2015-07-28T15:47:02 * kasparnet joined the channel
2015-07-28T15:59:48 * cindyli joined the channel
2015-07-28T16:31:09 * kasparne_ joined the channel
2015-07-28T16:33:09 * anastasiac has quit
2015-07-28T16:33:14 * kasparnet has quit
2015-07-28T16:44:16 * anastasiac joined the channel
2015-07-28T17:02:49 * michelled has quit
2015-07-28T17:07:13 * kasparne_ has quit
2015-07-28T17:07:48 * kasparnet joined the channel
2015-07-28T17:12:03 * kasparnet has quit
2015-07-28T17:21:30 <Bosmon> colinclark, simonjb - in terms of our general noodlings on immutability, I\'m speculating that the ChangeApplier could recognise IMMUTABLE REGIMES.....
2015-07-28T17:21:43 <Bosmon> That is, if the entirety of a change lies within such a regime, it can be handled immutably
2015-07-28T17:22:15 <Bosmon> My big concern about "universal immutability" is the huge performance risk, most notably for applications such as audio synthesis : P
2015-07-28T17:22:41 <simonjb> a regime would scope immutability?
2015-07-28T17:22:54 <Bosmon> But also thinking about, for example, the Nexus\' requirement to, say, broker an interaction where a mouse cursor is generating coordinates at 60fps - I\'m far from convinced that an immutable data structure is where we\'d want to be storing such things
2015-07-28T17:23:44 <Bosmon> simonjb - yes - that is we would recognise model areas either "by type" (if they happened to be implemented using a well-known immutable library such as Facebook\'s), or else "by metadata", using some kind of "policy" structure like the one that we use for mergePolicies
2015-07-28T17:24:00 <Bosmon> That states, "the following area of the following model should be handled immutably"
2015-07-28T17:24:10 <Bosmon> But I\'m imagining that immutability should actually become the default
2015-07-28T17:24:23 <Bosmon> Since the performance-critical applications seem like the exception rather than the rule
2015-07-28T17:24:58 <Bosmon> But interestingly I guess mutability is "contagious" in a way that immutability isn\'t
2015-07-28T17:25:15 <Bosmon> The slightest pollution of mutability in a model causes the entire thing to have to be treated mutably up to its root
2015-07-28T17:25:24 <simonjb> yes, agreed
2015-07-28T17:25:43 <simonjb> a mutable tree can contain immutable parts, but not the other way round
2015-07-28T17:25:45 <Bosmon> Well, this is just going to be tough
2015-07-28T17:25:59 <Bosmon> Since the areas that people want mutability will be in "small leaves"
2015-07-28T17:26:21 <Bosmon> There\'s no point having mutable models if they can\'t be observed
2015-07-28T17:26:36 <Bosmon> And if we want them to be observed without generating garbage, they will have to be observed by other mutable models
2015-07-28T17:26:47 <simonjb> I think it does depend on the performance of available persistent data structures for JavaScript, such as the Facebook one
2015-07-28T17:27:33 <simonjb> ideally a good implementation would mean minimal duplication in case of modification of part of the structure
2015-07-28T17:27:33 <Bosmon> Well, I think however performant they are, they can\'t avoid generating probably multiple pieces of garbage per modification.... I\'d be surprised if they could keep the cost to just a single object
2015-07-28T17:27:46 <Bosmon> That is, a single object per modification
2015-07-28T17:28:07 <Bosmon> That said, we don\'t have any implementation of the ChangeApplier that produces fewer pieces of garbage than that anyway
2015-07-28T17:28:40 <Bosmon> And at least the benefit of making things immutable make it clear how to share the updates amongst multiple pieces of cooperating models without generating FURTHER garbage
2015-07-28T17:29:36 <Bosmon> But somewhere up the containment hierarchy, I guess, has to be SOMETHING mutable... otherwise we end up INCREMENTING THE ENTIRE WORLD whenever we want any update in any area of a "mega-model"...
2015-07-28T17:30:26 <simonjb> and then we are in Haskell!
2015-07-28T17:30:30 <Bosmon> Quite
2015-07-28T17:31:37 <Bosmon> Well, at least the parts of the ChangeApplier that actually ENACT mutation are pretty small and well-contained
2015-07-28T17:32:03 <Bosmon> So it\'s easy to imagine making that engine aware of the possibility of immutable application
2015-07-28T17:32:23 <Bosmon> The big problem is, how can we then gain the value that we want from that elsewhere in the design
2015-07-28T17:33:40 <Bosmon> For example, "implicit model relay" between two models which are both immutable should simply be a matter of copying object reference
2015-07-28T17:34:00 <Bosmon> Ok
2015-07-28T17:35:15 <Bosmon> So I imagine what\'s required is i) the "policy" structure I mentioned, that will determine, given any model path, whether it is in an "immutable area", and ii) extending the ChangeApplier protocol to encode whether the "value" held in a change has arisen from such an area or not
2015-07-28T17:35:59 <simonjb> do I have the right idea in mind? the component model reference would be the point of mutability and any update to the model results in a new model (potentially with shared data, depending on implementation) and we update the component\'s reference to the new model iteration?
2015-07-28T17:36:23 <Bosmon> If we were using genuine immutable datastructures throughout, this could all be done on type-based detection, but as I mentioned in the private chat, it would be very helpful to be able to start off by treating JS builtins as if they were immutable - I guess we could start enforcing this by calling Object.freeze() on such things but it would alarm users a lot I think to do this up front
2015-07-28T17:36:26 <Bosmon> simonjb - that\'s exactly right, yes
2015-07-28T17:36:38 <Bosmon> The field called "model" would be the "root of mutation"
2015-07-28T17:36:54 <simonjb> yep
2015-07-28T17:36:59 <Bosmon> Thankfully the changes I already made to the ChangeApplier allows us to accommodate this without violating too many MORE assumptions
2015-07-28T17:37:14 <Bosmon> Since the assumption of the "old ChangeApplier" was that the model reference remained fixed for the lifetime of the component
2015-07-28T17:37:35 <Bosmon> Once this branch is merged in, we\'ll have flushed out the last clients who were depending on this assumption
2015-07-28T17:38:26 <Bosmon> Ironically this was necessary just to support the existing kinds of immutable models that we needed to support - those consisting of JS primitives : P
2015-07-28T17:40:38 <Bosmon> Well, the mere construction of a "change" object requires at least one piece of garbage....
2015-07-28T17:40:43 * alanharnum has quit
2015-07-28T17:40:54 <Bosmon> I do wonder HOW we are going to support models in JS that update at 60fps without a drop
2015-07-28T17:42:13 <simonjb> Bosmon: do we have any numbers for how close/far we are from that now?
2015-07-28T17:42:18 <Bosmon> simonjb - none
2015-07-28T17:42:36 <Bosmon> Although colinclark has enough experience with Flocking to show that it will be extremely tough
2015-07-28T17:42:41 * clown joined the channel
2015-07-28T17:42:55 <Bosmon> To the extent that he is waiting for the time he can move all the performance-critical parts of flocking into a web worker
2015-07-28T17:43:42 <colinclark> I dont\' imagine we\'ll ever have an "Audio Worker" implementation that includes:
2015-07-28T17:43:54 <colinclark> a) a realtime garbage collector implementation
2015-07-28T17:43:56 * alanharnum joined the channel
2015-07-28T17:44:07 <Bosmon> I think your current survivable buffer size is 1024 samples?
2015-07-28T17:44:09 <colinclark> or b) the ability to turn off or manually trigger garbage collection
2015-07-28T17:44:12 <colinclark> in the main thread, yes
2015-07-28T17:44:18 <Bosmon> ok
2015-07-28T17:44:24 <colinclark> out of the main thread, the major threat is the garbage collector
2015-07-28T17:44:32 <colinclark> everything else is looking much, much better
2015-07-28T17:44:46 <Bosmon> Well.... I can\'t see how we can create any kind of model relay-type system that creates ZERO garbage
2015-07-28T17:44:48 <colinclark> but I won\'t be able to control being preempted by a garbage collector that was simply not designed to meet realtime constraints
2015-07-28T17:44:56 <colinclark> Which is fine
2015-07-28T17:45:11 <colinclark> I think we can agree that Flocking "other universe" is a very extreme "materialization strategy"
2015-07-28T17:45:21 <Bosmon> I guess we could in theory, if none of the changes had mutated the structure of the model
2015-07-28T17:45:21 <simonjb> an option would be manual, or at least custom, memory management
2015-07-28T17:45:25 <colinclark> with a strangely one-sided Nexus-like API mediating it
2015-07-28T17:45:31 <Bosmon> And we very aggressively reused existing objects
2015-07-28T17:45:37 <colinclark> Yes, exactly
2015-07-28T17:45:47 <Bosmon> But that\'s totally inconsistent with the "immutable" model we\'re considering
2015-07-28T17:45:51 <simonjb> where we write something that is more domain specific for realtime
2015-07-28T17:45:59 <colinclark> yes, we\'ll have to do that
2015-07-28T17:45:59 <Bosmon> Yes, it looks like it
2015-07-28T17:46:10 <Bosmon> The "realtime ChangeApplier" will be entirely distinct from the "immutable ChangeApplier"
2015-07-28T17:46:13 <colinclark> my sense is that the realistic limit for "realtime" for us is somewhere between 60-100 Hz
2015-07-28T17:46:19 <Bosmon> Other than operating something like the same semantics
2015-07-28T17:46:24 <colinclark> anything faster must represent another universe
2015-07-28T17:46:38 <colinclark> I forget why Adam once told me that 100 Hz was about the standard limit for performance controllers
2015-07-28T17:46:44 <colinclark> i.e. MIDI or OSC audio controllers
2015-07-28T17:46:44 <Bosmon> Well, that at least puts our application of a pointing device within scope
2015-07-28T17:46:57 <colinclark> but 60 Hz is probably a reasonable target
2015-07-28T17:47:19 <colinclark> but I guess the issue still is how much "headroom" you\'ve got, time-wise
2015-07-28T17:47:22 <Bosmon> I don\'t think that P4A will require us to meet any harder target than that "in-process"
2015-07-28T17:47:27 <colinclark> garbage is only half the issue
2015-07-28T17:47:45 <colinclark> certainly with Aconite, trying to squeeze all computation, including model relay, into 16ms is pretty challenging
2015-07-28T17:48:04 <colinclark> whcih goes back to simonjb\'s point about the performance of the immutable data structure implementations, I guess
2015-07-28T17:48:35 <Bosmon> As HICKEY points out, immutability is definitely an "infinite resources" style of implementation
2015-07-28T17:48:48 <Bosmon> Assuming you have infinite resources, immutability uses them the most efficiently : P
2015-07-28T17:49:44 <simonjb> "LISP programmers know the value of everything and the cost of nothing" Alan Perlis
2015-07-28T17:49:54 <Bosmon> :)
2015-07-28T17:50:01 <Bosmon> Quite
2015-07-28T17:50:11 <Bosmon> From the same guy who speculated that code might be disposable, like a soap-bubble : P
2015-07-28T17:50:16 <simonjb> indeed
2015-07-28T17:50:53 * colinclark has quit
2015-07-28T17:52:09 <Bosmon> I guess only something like the ChangeApplier could promise to "solve" this problem anyway
2015-07-28T17:52:21 <Bosmon> In that people will write the same "declaration" on both sides of the fence
2015-07-28T17:52:42 <Bosmon> And on one side of the fence, the declaration is honored immutably, and on the other side it is honoured with mutation
2015-07-28T17:53:07 <Bosmon> Down to primitives like determining whether a particular part of the model has changed or not, which will be implemented very differently on either side
'

